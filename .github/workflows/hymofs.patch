diff -uNr -x '*.o' -x '*.ko' -x '*.mod' -x '*.mod.c' -x modules.order -x Module.symvers -x '.*.cmd' a/fs/Kconfig c/fs/Kconfig
--- a/fs/Kconfig	2025-12-09 22:34:08.018998258 +0800
+++ c/fs/Kconfig	2025-12-10 14:22:25.866955409 +0800
@@ -405,4 +405,10 @@
 config IO_WQ
 	bool
 
+config HYMOFS
+	bool "HymoFS support"
+	default y
+	help
+	  HymoFS is a kernel-level path manipulation and hiding framework.
+
 endmenu
diff -uNr -x '*.o' -x '*.ko' -x '*.mod' -x '*.mod.c' -x modules.order -x Module.symvers -x '.*.cmd' a/fs/namei.c c/fs/namei.c
--- a/fs/namei.c	2025-12-09 22:34:08.090839610 +0800
+++ c/fs/namei.c	2025-12-10 14:22:25.868955355 +0800
@@ -45,6 +45,11 @@
 #include "internal.h"
 #include "mount.h"
 
+#ifdef CONFIG_HYMOFS
+struct filename *(*hymofs_getname_hook)(struct filename *name) = NULL;
+EXPORT_SYMBOL(hymofs_getname_hook);
+#endif
+
 /* [Feb-1997 T. Schoebel-Theuer]
  * Fundamental changes in the pathname lookup mechanisms (namei)
  * were necessary because of omirr.  The reason is that omirr needs
@@ -202,6 +207,10 @@
 	result->uptr = filename;
 	result->aname = NULL;
 	audit_getname(result);
+#ifdef CONFIG_HYMOFS
+	if (hymofs_getname_hook)
+		return hymofs_getname_hook(result);
+#endif
 	return result;
 }
 
diff -uNr -x '*.o' -x '*.ko' -x '*.mod' -x '*.mod.c' -x modules.order -x Module.symvers -x '.*.cmd' a/fs/readdir.c c/fs/readdir.c
--- a/fs/readdir.c	2025-12-09 22:34:08.141435352 +0800
+++ c/fs/readdir.c	2025-12-10 15:47:42.718868909 +0800
@@ -24,6 +24,16 @@
 
 #include <asm/unaligned.h>
 
+#ifdef CONFIG_HYMOFS
+typedef bool (*hymofs_filldir_hook_t)(struct file *file, const char *name, int namlen, u64 ino, unsigned int d_type);
+hymofs_filldir_hook_t hymofs_filldir_hook = NULL;
+EXPORT_SYMBOL(hymofs_filldir_hook);
+
+typedef void (*hymofs_getdents64_hook_t)(struct file *file, struct linux_dirent64 __user **dirent, int *count, struct dir_context *ctx);
+hymofs_getdents64_hook_t hymofs_getdents64_hook = NULL;
+EXPORT_SYMBOL(hymofs_getdents64_hook);
+#endif
+
 /*
  * Some filesystems were never converted to '->iterate_shared()'
  * and their directory iterators want the inode lock held for
@@ -249,6 +259,9 @@
 
 struct getdents_callback {
 	struct dir_context ctx;
+#ifdef CONFIG_HYMOFS
+	struct file *file;
+#endif
 	struct linux_dirent __user * current_dir;
 	int prev_reclen;
 	int count;
@@ -266,6 +279,11 @@
 		sizeof(long));
 	int prev_reclen;
 
+#ifdef CONFIG_HYMOFS
+	if (hymofs_filldir_hook && hymofs_filldir_hook(buf->file, name, namlen, ino, d_type))
+		return true;
+#endif
+
 	buf->error = verify_dirent_name(name, namlen);
 	if (unlikely(buf->error))
 		return false;
@@ -319,11 +337,15 @@
 	if (!f.file)
 		return -EBADF;
 
+#ifdef CONFIG_HYMOFS
+	buf.file = f.file;
+#endif
+
 	error = iterate_dir(f.file, &buf.ctx);
 	if (error >= 0)
 		error = buf.error;
 	if (buf.prev_reclen) {
-		struct linux_dirent __user * lastdirent;
+		struct linux_dirent64 __user * lastdirent;
 		lastdirent = (void __user *)buf.current_dir - buf.prev_reclen;
 
 		if (put_user(buf.ctx.pos, &lastdirent->d_off))
@@ -337,6 +359,9 @@
 
 struct getdents_callback64 {
 	struct dir_context ctx;
+#ifdef CONFIG_HYMOFS
+	struct file *file;
+#endif
 	struct linux_dirent64 __user * current_dir;
 	int prev_reclen;
 	int count;
@@ -353,6 +378,11 @@
 		sizeof(u64));
 	int prev_reclen;
 
+#ifdef CONFIG_HYMOFS
+	if (hymofs_filldir_hook && hymofs_filldir_hook(buf->file, name, namlen, ino, d_type))
+		return true;
+#endif
+
 	buf->error = verify_dirent_name(name, namlen);
 	if (unlikely(buf->error))
 		return false;
@@ -402,9 +432,17 @@
 	if (!f.file)
 		return -EBADF;
 
+#ifdef CONFIG_HYMOFS
+	buf.file = f.file;
+#endif
+
 	error = iterate_dir(f.file, &buf.ctx);
 	if (error >= 0)
 		error = buf.error;
+#ifdef CONFIG_HYMOFS
+	if (hymofs_getdents64_hook)
+		hymofs_getdents64_hook(f.file, &buf.current_dir, &buf.count, &buf.ctx);
+#endif
 	if (buf.prev_reclen) {
 		struct linux_dirent64 __user * lastdirent;
 		typeof(lastdirent->d_off) d_off = buf.ctx.pos;
@@ -501,6 +539,9 @@
 
 struct compat_getdents_callback {
 	struct dir_context ctx;
+#ifdef CONFIG_HYMOFS
+	struct file *file;
+#endif
 	struct compat_linux_dirent __user *current_dir;
 	int prev_reclen;
 	int count;
@@ -518,6 +559,11 @@
 		namlen + 2, sizeof(compat_long_t));
 	int prev_reclen;
 
+#ifdef CONFIG_HYMOFS
+	if (hymofs_filldir_hook && hymofs_filldir_hook(buf->file, name, namlen, ino, d_type))
+		return true;
+#endif
+
 	buf->error = verify_dirent_name(name, namlen);
 	if (unlikely(buf->error))
 		return false;
@@ -570,6 +616,10 @@
 	if (!f.file)
 		return -EBADF;
 
+#ifdef CONFIG_HYMOFS
+	buf.file = f.file;
+#endif
+
 	error = iterate_dir(f.file, &buf.ctx);
 	if (error >= 0)
 		error = buf.error;
diff -uNr -x '*.o' -x '*.ko' -x '*.mod' -x '*.mod.c' -x modules.order -x Module.symvers -x '.*.cmd' a/fs/stat.c c/fs/stat.c
--- a/fs/stat.c	2025-12-09 22:34:08.158706619 +0800
+++ c/fs/stat.c	2025-12-10 14:22:25.871366626 +0800
@@ -26,6 +26,11 @@
 #include "internal.h"
 #include "mount.h"
 
+#ifdef CONFIG_HYMOFS
+void (*hymofs_vfs_getattr_hook)(const struct path *path, struct kstat *stat) = NULL;
+EXPORT_SYMBOL(hymofs_vfs_getattr_hook);
+#endif
+
 /**
  * generic_fillattr - Fill in the basic attributes from the inode struct
  * @idmap:		idmap of the mount the inode was found from
@@ -137,6 +142,10 @@
 					    query_flags | AT_GETATTR_NOSEC);
 
 	generic_fillattr(idmap, request_mask, inode, stat);
+#ifdef CONFIG_HYMOFS
+	if (hymofs_vfs_getattr_hook)
+		hymofs_vfs_getattr_hook(path, stat);
+#endif
 	return 0;
 }
 EXPORT_SYMBOL(vfs_getattr_nosec);
diff -uNr -x '*.o' -x '*.ko' -x '*.mod' -x '*.mod.c' -x modules.order -x Module.symvers -x '.*.cmd' a/hymofs_lkm/hymofs.c c/hymofs_lkm/hymofs.c
--- a/hymofs_lkm/hymofs.c	1970-01-01 08:00:00.000000000 +0800
+++ c/hymofs_lkm/hymofs.c	2025-12-10 17:11:39.712693590 +0800
@@ -0,0 +1,489 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/hashtable.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/namei.h>
+#include <linux/dirent.h>
+#include <linux/time.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/path.h>
+#include <linux/dcache.h>
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("HymoFS");
+MODULE_DESCRIPTION("HymoFS Instrumented LKM");
+
+#define HYMO_HASH_BITS 10
+#define HYMOFS_PROTOCOL_VERSION 4
+
+struct hymo_entry {
+    char *src;
+    char *target;
+    unsigned char type;
+    struct hlist_node node;
+};
+
+struct hymo_hide_entry {
+    char *path;
+    struct hlist_node node;
+};
+
+struct hymo_inject_entry {
+    char *dir;
+    struct hlist_node node;
+};
+
+static DEFINE_HASHTABLE(hymo_paths, HYMO_HASH_BITS);
+static DEFINE_HASHTABLE(hymo_hide_paths, HYMO_HASH_BITS);
+static DEFINE_HASHTABLE(hymo_inject_dirs, HYMO_HASH_BITS);
+static DEFINE_SPINLOCK(hymo_lock);
+static atomic_t hymo_version = ATOMIC_INIT(0);
+
+/* Per-CPU buffers to avoid allocation overhead in hot paths */
+static DEFINE_PER_CPU(char *, hymo_path_buffer);
+
+/* Hook function pointers */
+extern struct filename *(*hymofs_getname_hook)(struct filename *name);
+extern bool (*hymofs_filldir_hook)(struct file *file, const char *name, int namlen, u64 ino, unsigned int d_type);
+extern void (*hymofs_vfs_getattr_hook)(const struct path *path, struct kstat *stat);
+extern void (*hymofs_getdents64_hook)(struct file *file, struct linux_dirent64 __user **dirent, int *count, struct dir_context *ctx);
+
+static void hymo_cleanup(void) {
+    struct hymo_entry *entry;
+    struct hymo_hide_entry *hide_entry;
+    struct hymo_inject_entry *inject_entry;
+    struct hlist_node *tmp;
+    int bkt;
+    hash_for_each_safe(hymo_paths, bkt, tmp, entry, node) {
+        hash_del(&entry->node);
+        kfree(entry->src);
+        kfree(entry->target);
+        kfree(entry);
+    }
+    hash_for_each_safe(hymo_hide_paths, bkt, tmp, hide_entry, node) {
+        hash_del(&hide_entry->node);
+        kfree(hide_entry->path);
+        kfree(hide_entry);
+    }
+    hash_for_each_safe(hymo_inject_dirs, bkt, tmp, inject_entry, node) {
+        hash_del(&inject_entry->node);
+        kfree(inject_entry->dir);
+        kfree(inject_entry);
+    }
+}
+
+static bool hymofs_should_hide(const char *pathname)
+{
+    unsigned long flags;
+    struct hymo_hide_entry *entry;
+    u32 hash;
+    bool found = false;
+    if (atomic_read(&hymo_version) == 0) return false;
+    if (!pathname) return false;
+    
+    if (hash_empty(hymo_hide_paths)) return false;
+
+    hash = full_name_hash(NULL, pathname, strlen(pathname));
+    spin_lock_irqsave(&hymo_lock, flags);
+    hash_for_each_possible(hymo_hide_paths, entry, node, hash) {
+        if (strcmp(entry->path, pathname) == 0) {
+            found = true;
+            break;
+        }
+    }
+    spin_unlock_irqrestore(&hymo_lock, flags);
+    return found;
+}
+
+static char *hymofs_resolve_target(const char *pathname)
+{
+    unsigned long flags;
+    struct hymo_entry *entry;
+    u32 hash;
+    char *target = NULL;
+
+    if (atomic_read(&hymo_version) == 0) return NULL;
+    if (!pathname) return NULL;
+    
+    if (hash_empty(hymo_paths)) return NULL;
+
+    hash = full_name_hash(NULL, pathname, strlen(pathname));
+
+    spin_lock_irqsave(&hymo_lock, flags);
+    hash_for_each_possible(hymo_paths, entry, node, hash) {
+        if (strcmp(entry->src, pathname) == 0) {
+            target = kstrdup(entry->target, GFP_ATOMIC);
+            break;
+        }
+    }
+    spin_unlock_irqrestore(&hymo_lock, flags);
+    return target;
+}
+
+static bool hymofs_should_spoof_mtime(const char *pathname)
+{
+    unsigned long flags;
+    struct hymo_inject_entry *entry;
+    u32 hash;
+    bool found = false;
+
+    if (atomic_read(&hymo_version) == 0) return false;
+    if (!pathname) return false;
+    
+    if (hash_empty(hymo_inject_dirs)) return false;
+
+    hash = full_name_hash(NULL, pathname, strlen(pathname));
+
+    spin_lock_irqsave(&hymo_lock, flags);
+    hash_for_each_possible(hymo_inject_dirs, entry, node, hash) {
+        if (strcmp(entry->dir, pathname) == 0) {
+            found = true;
+            break;
+        }
+    }
+    spin_unlock_irqrestore(&hymo_lock, flags);
+    return found;
+}
+
+static struct filename *my_getname_hook(struct filename *name)
+{
+    char *target;
+    if (hymofs_should_hide(name->name)) {
+        putname(name);
+        return ERR_PTR(-ENOENT);
+    } else {
+        target = hymofs_resolve_target(name->name);
+        if (target) {
+            putname(name);
+            name = getname_kernel(target);
+            kfree(target);
+        }
+    }
+    return name;
+}
+
+static bool my_filldir_hook(struct file *file, const char *name, int namlen, u64 ino, unsigned int d_type)
+{
+    char *buf;
+    bool hide = false;
+    char *p;
+    int path_len;
+    
+    if (atomic_read(&hymo_version) == 0 || hash_empty(hymo_hide_paths)) return false;
+
+    buf = get_cpu_var(hymo_path_buffer);
+    if (!buf) {
+        put_cpu_var(hymo_path_buffer);
+        return false;
+    }
+
+    p = d_path(&file->f_path, buf, PAGE_SIZE);
+    if (!IS_ERR(p)) {
+        path_len = strlen(p);
+        /* 
+         * d_path fills buffer from the end. We cannot append to it directly 
+         * as it would overflow the page. We must move it to the start first.
+         */
+        if (path_len + 1 + namlen + 1 < PAGE_SIZE) {
+            memmove(buf, p, path_len + 1); /* Move to start of buffer */
+            
+            if (path_len > 1 && buf[path_len-1] != '/') strcat(buf, "/");
+            else if (path_len == 1 && buf[0] == '/') {}
+            else strcat(buf, "/");
+            
+            strncat(buf, name, namlen);
+            if (hymofs_should_hide(buf)) hide = true;
+        }
+    }
+    
+    put_cpu_var(hymo_path_buffer);
+    return hide;
+}
+
+static void my_vfs_getattr_hook(const struct path *path, struct kstat *stat)
+{
+    char *buf;
+    char *p;
+    
+    if (atomic_read(&hymo_version) == 0 || hash_empty(hymo_inject_dirs)) return;
+
+    buf = get_cpu_var(hymo_path_buffer);
+    if (!buf) {
+        put_cpu_var(hymo_path_buffer);
+        return;
+    }
+
+    p = d_path(path, buf, PAGE_SIZE);
+    if (!IS_ERR(p)) {
+        if (hymofs_should_spoof_mtime(p)) {
+            ktime_get_real_ts64(&stat->mtime);
+            stat->ctime = stat->mtime;
+        }
+    }
+    put_cpu_var(hymo_path_buffer);
+}
+
+static void my_getdents64_hook(struct file *file, struct linux_dirent64 __user **dirent, int *count, struct dir_context *ctx)
+{
+    char *buf;
+    char *dir_path;
+    unsigned long flags;
+    struct hymo_entry *entry;
+    int bkt;
+    
+    if (atomic_read(&hymo_version) == 0 || hash_empty(hymo_paths)) return;
+    
+    buf = get_cpu_var(hymo_path_buffer);
+    if (!buf) {
+        put_cpu_var(hymo_path_buffer);
+        return;
+    }
+    
+    dir_path = d_path(&file->f_path, buf, PAGE_SIZE);
+    if (IS_ERR(dir_path)) {
+        put_cpu_var(hymo_path_buffer);
+        return;
+    }
+    
+    if (hymofs_should_spoof_mtime(dir_path)) {
+        size_t dir_len = strlen(dir_path);
+        spin_lock_irqsave(&hymo_lock, flags);
+        hash_for_each(hymo_paths, bkt, entry, node) {
+            if (strncmp(entry->src, dir_path, dir_len) == 0) {
+                char *sub = entry->src + dir_len;
+                if (*sub == '/') sub++;
+                if (strchr(sub, '/') == NULL) {
+                    int namlen = strlen(sub);
+                    int reclen = ALIGN(offsetof(struct linux_dirent64, d_name) + namlen + 1, sizeof(u64));
+                    
+                    if (reclen <= *count) {
+                        struct linux_dirent64 __user *d = *dirent;
+                        
+                        if (put_user(0, &d->d_ino) ||
+                            put_user(0, &d->d_off) ||
+                            put_user(reclen, &d->d_reclen) ||
+                            put_user(entry->type, &d->d_type) ||
+                            copy_to_user(d->d_name, sub, namlen) ||
+                            put_user(0, (char __user *)d->d_name + namlen)) {
+                                continue;
+                        }
+                        
+                        *dirent = (void __user *)d + reclen;
+                        *count -= reclen;
+                        continue;
+                    }
+                }
+            }
+        }
+        spin_unlock_irqrestore(&hymo_lock, flags);
+    }
+    put_cpu_var(hymo_path_buffer);
+}
+
+static ssize_t hymo_ctl_write(struct file *file, const char __user *buffer,
+                  size_t count, loff_t *pos)
+{
+    char *cmd, *p, *op, *arg1, *arg2;
+    unsigned long flags;
+    struct hymo_entry *entry;
+    struct hymo_hide_entry *hide_entry;
+    struct hymo_inject_entry *inject_entry;
+    u32 hash;
+    bool found;
+
+    if (count > 8192) return -EINVAL;
+    cmd = kmalloc(count + 1, GFP_KERNEL);
+    if (!cmd) return -ENOMEM;
+    if (copy_from_user(cmd, buffer, count)) { kfree(cmd); return -EFAULT; }
+    cmd[count] = 0;
+
+    p = strim(cmd);
+    op = strsep(&p, " ");
+    if (!op) { kfree(cmd); return -EINVAL; }
+
+    spin_lock_irqsave(&hymo_lock, flags);
+
+    if (strcmp(op, "clear") == 0) {
+        hymo_cleanup();
+        atomic_inc(&hymo_version);
+    } else if (strcmp(op, "add") == 0) {
+        arg1 = strsep(&p, " ");
+        arg2 = strsep(&p, " ");
+        char *arg3 = p;
+        if (arg1 && arg2) {
+            arg2 = strim(arg2);
+            hash = full_name_hash(NULL, arg1, strlen(arg1));
+            found = false;
+            hash_for_each_possible(hymo_paths, entry, node, hash) {
+                if (strcmp(entry->src, arg1) == 0) {
+                    kfree(entry->target);
+                    entry->target = kstrdup(arg2, GFP_ATOMIC);
+                    if (arg3) {
+                        int type = 0;
+                        if (kstrtoint(strim(arg3), 10, &type)) type = 0;
+                        entry->type = (unsigned char)type;
+                    } else {
+                        entry->type = 0;
+                    }
+                    found = true;
+                    break;
+                }
+            }
+            if (!found) {
+                entry = kmalloc(sizeof(*entry), GFP_ATOMIC);
+                if (entry) {
+                    entry->src = kstrdup(arg1, GFP_ATOMIC);
+                    entry->target = kstrdup(arg2, GFP_ATOMIC);
+                    if (arg3) {
+                        int type = 0;
+                        if (kstrtoint(strim(arg3), 10, &type)) type = 0;
+                        entry->type = (unsigned char)type;
+                    } else {
+                        entry->type = 0;
+                    }
+                    if (entry->src && entry->target) hash_add(hymo_paths, &entry->node, hash);
+                    else { kfree(entry->src); kfree(entry->target); kfree(entry); }
+                }
+            }
+            atomic_inc(&hymo_version);
+        }
+    } else if (strcmp(op, "hide") == 0) {
+        arg1 = p;
+        if (arg1) {
+            arg1 = strim(arg1);
+            hash = full_name_hash(NULL, arg1, strlen(arg1));
+            found = false;
+            hash_for_each_possible(hymo_hide_paths, hide_entry, node, hash) {
+                if (strcmp(hide_entry->path, arg1) == 0) {
+                    found = true;
+                    break;
+                }
+            }
+            if (!found) {
+                hide_entry = kmalloc(sizeof(*hide_entry), GFP_ATOMIC);
+                if (hide_entry) {
+                    hide_entry->path = kstrdup(arg1, GFP_ATOMIC);
+                    if (hide_entry->path) hash_add(hymo_hide_paths, &hide_entry->node, hash);
+                    else kfree(hide_entry);
+                }
+            }
+            atomic_inc(&hymo_version);
+        }
+    } else if (strcmp(op, "inject") == 0) {
+        arg1 = p;
+        if (arg1) {
+            arg1 = strim(arg1);
+            hash = full_name_hash(NULL, arg1, strlen(arg1));
+            found = false;
+            hash_for_each_possible(hymo_inject_dirs, inject_entry, node, hash) {
+                if (strcmp(inject_entry->dir, arg1) == 0) {
+                    found = true;
+                    break;
+                }
+            }
+            if (!found) {
+                inject_entry = kmalloc(sizeof(*inject_entry), GFP_ATOMIC);
+                if (inject_entry) {
+                    inject_entry->dir = kstrdup(arg1, GFP_ATOMIC);
+                    if (inject_entry->dir) hash_add(hymo_inject_dirs, &inject_entry->node, hash);
+                    else kfree(inject_entry);
+                }
+            }
+            atomic_inc(&hymo_version);
+        }
+    }
+    spin_unlock_irqrestore(&hymo_lock, flags);
+    kfree(cmd);
+    return count;
+}
+
+static int hymo_ctl_show(struct seq_file *m, void *v)
+{
+    struct hymo_entry *entry;
+    struct hymo_hide_entry *hide_entry;
+    int bkt;
+    unsigned long flags;
+    seq_printf(m, "HymoFS Protocol: %d\n", HYMOFS_PROTOCOL_VERSION);
+    seq_printf(m, "HymoFS Config Version: %d\n", atomic_read(&hymo_version));
+    
+    spin_lock_irqsave(&hymo_lock, flags);
+    hash_for_each(hymo_paths, bkt, entry, node) {
+        seq_printf(m, "add %s -> %s\n", entry->src, entry->target);
+    }
+    hash_for_each(hymo_hide_paths, bkt, hide_entry, node) {
+        seq_printf(m, "hide %s\n", hide_entry->path);
+    }
+    spin_unlock_irqrestore(&hymo_lock, flags);
+    return 0;
+}
+
+static int hymo_ctl_open(struct inode *inode, struct file *file)
+{
+    return single_open(file, hymo_ctl_show, NULL);
+}
+
+static const struct proc_ops hymo_ctl_ops = {
+    .proc_open    = hymo_ctl_open,
+    .proc_read    = seq_read,
+    .proc_lseek   = seq_lseek,
+    .proc_release = single_release,
+    .proc_write   = hymo_ctl_write,
+};
+
+static int __init hymofs_init(void)
+{
+    int cpu;
+    spin_lock_init(&hymo_lock);
+    hash_init(hymo_paths);
+    hash_init(hymo_hide_paths);
+    hash_init(hymo_inject_dirs);
+    
+    /* Allocate per-cpu buffers */
+    for_each_possible_cpu(cpu) {
+        char *buf = (char *)__get_free_page(GFP_KERNEL);
+        if (!buf) {
+            pr_err("HymoFS: failed to allocate per-cpu buffer\n");
+            return -ENOMEM;
+        }
+        *per_cpu_ptr(&hymo_path_buffer, cpu) = buf;
+    }
+    
+    proc_create("hymo_ctl", 0660, NULL, &hymo_ctl_ops);
+    
+    hymofs_getname_hook = my_getname_hook;
+    hymofs_filldir_hook = my_filldir_hook;
+    hymofs_vfs_getattr_hook = my_vfs_getattr_hook;
+    hymofs_getdents64_hook = my_getdents64_hook;
+    
+    pr_info("HymoFS: initialized (LKM Mode)\n");
+    return 0;
+}
+
+static void __exit hymofs_exit(void)
+{
+    int cpu;
+    hymofs_getname_hook = NULL;
+    hymofs_filldir_hook = NULL;
+    hymofs_vfs_getattr_hook = NULL;
+    hymofs_getdents64_hook = NULL;
+    
+    remove_proc_entry("hymo_ctl", NULL);
+    hymo_cleanup();
+    
+    /* Free per-cpu buffers */
+    for_each_possible_cpu(cpu) {
+        char *buf = *per_cpu_ptr(&hymo_path_buffer, cpu);
+        if (buf) free_page((unsigned long)buf);
+    }
+    
+    pr_info("HymoFS: unloaded\n");
+}
+
+module_init(hymofs_init);
+module_exit(hymofs_exit);
diff -uNr -x '*.o' -x '*.ko' -x '*.mod' -x '*.mod.c' -x modules.order -x Module.symvers -x '.*.cmd' a/hymofs_lkm/Makefile c/hymofs_lkm/Makefile
--- a/hymofs_lkm/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ c/hymofs_lkm/Makefile	2025-12-10 15:00:50.020977840 +0800
@@ -0,0 +1,10 @@
+# Point this to your kernel source directory
+KDIR ?= /lib/modules/$(shell uname -r)/build
+
+obj-m += hymofs.o
+
+all:
+	make -C $(KDIR) M=$(PWD) modules
+
+clean:
+	make -C $(KDIR) M=$(PWD) clean
